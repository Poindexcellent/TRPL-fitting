function ModelTRPL(recombFunc,genFunc,diffFunc)

%     ModelTRPL.m analyzes and fits time-resolved photoluminescence (TRPL)
%     data to a model incorporating generation, diffusion, and recombination.
%     The script is intended to be modular such that different models for
%     generation, recombination, and diffusion can be swapped in and out in
%     sub-functions ('genFunc', 'diffFunc', and 'recombFunc').
% 
%     This model uses a 1D finite difference approach to calculate the
%     photoluminescence at every point in space and time within the film.
% 
%     Throughout ModelTRPL and all sub-functions, any values that need to be
%     hard-coded in are indicated with '#' symbols preceding comments.
%     Author's notes, used to note places for future improvement (as
%     distinguished from comments), are indicated by a double asterisk '**'.
% 
%     More information to be added later for version 1.0.
% 
%     Created January 29, 2016, Jeremy R. Poindexter
%     Last modified July 11, 2016, Jeremy R. Poindexter
%     Current version: v0.1

%% 0. **Version improvement notes:
%     1/29/2016 - 7/11/2016: v0.1
% 
%     To improve in future versions:
%     - read data from figure rather than workspace (Section 1)
%     - implement selection of parameters via GUI and/or dialog boxes
%     (Sections 2-5)
%     - implement ambipolar diffusion (section 3)
%     - test n^2 and n^3 recombination terms (section 4)

    
%% 1. Set up data for analysis in new figure.

% **Do typical stuff, like load the data from a figure, but only if it's
% visible. Set this up to only analyze one curve at a time. If you find
% multiple visible curves, include some option / prompt to ask "which curve do
% you want to analyze?" or something similar.


%% 2. Define generation.

% **Defining generation is the easiest because because there's no dependence on
% \Delta_n (and hence no worry about injection dependence, for example).

% **The generation parameters are *passed* to a function 'genFunc', which
% calculates the proper generation term / function.


%%% 2a-temp. Temporary hard-coded generation types and injection levels:
genType = 'delta';          %# temporary 'genType' declaration
injectType = 'low';         %# temporary 'injectType' declaration


%% 3. Define diffusion.

% **Start with a simple number, defined in cm^2/sec. Start with two options --
% minority-carrier, or ambipolar diffusion.

% **Raf's approach: diffusivity is a function of n, and the value for the
% previous timestep is used. Not strictly as accurate but may give similar
% results.

% **The diffusion parameters are *passed* to a function 'diffFunc', which will
% likely need to be in 'switch/case' form to deal with different cases for D,
% which is ultimately the output needed.


%% 4. Define recombination.

%** The hard one. In high injection, there are \Delta_n^2 and \Delta_n^3 terms.
% Rewriting these in matrix formulation might be tricky, or not possible,
% because equation is suddenly nonlinear. Hmm...

% **One can still use finite difference methods to calculate \Delta_n at a given
% point, with multiple (3?) 'for' loops. The complexity will vary for
% different recombination functions. Thus, different options should be passed
% to the 'recombFunc' function and may best be treated with different
% 'switch/case' functions.


% Open a dialog box to choose options:

%%% **NEED TO GET THIS WORKING BETTER.

% % d_ = dialog('Position',[300 300 400 400],'Name','Recombination.');
% % xpos = -600;    %# screen x-position of dialog box
% % ypos = 300;     %# screen y-position of dialog box
% % dwidth = 300;   %# screen width of dialog box
% % dheight = 150;  %# screen height of dialog box
% % 
% % recombType = zeros(3,1);
% % 
% % d_ = dialog('Position',[xpos ypos dwidth dheight],'Name','Set recombination preferences.');
% % 
% % txt = uicontrol('Parent',d_,'Style','text','Position',[0 dheight-20 dwidth-20 15],...
% %     'String','Check the desired recombination model.'); 
% % 
% % boxA = uicontrol('Parent',d_,'Style','checkbox',...
% %     'Position',[25 dheight-50 dwidth-20 15],...
% %     'String','monomolecular','CallBack',{@updateBox, boxA});
% % 
% % boxB = uicontrol('Parent',d_,'Style','checkbox',...
% %     'Position',[25 dheight-75 dwidth-20 15],...
% %     'String','bimolecular','CallBack',{@updateBox, boxB});
% % recombType(2) = boxB.Value;
% % 
% % boxC = uicontrol('Parent',d_,'Style','checkbox',...
% %     'Position',[25 dheight-100 dwidth-20 15],...
% %     'String','trimolecular','CallBack',{@updateBox, boxC});
% % recombType(3) = boxC.Value;
% % 
% % btn = uicontrol('Parent',d_,...
% %     'Position',[dwidth/2-35 20 70 25],...
% %     'String','Close',...
% %     'Callback','delete(gcf)');



%% 5. Define boundary conditions (SRV).

% **Should be pretty easy, given SRV and D. Consider injection dependence of SRV
% as an option. Boundary conditions could be passed to a function like
% 'SRVcalc' or something, or simply incorprated into 'nSolve' directly.

%% 5-temp. Temporary declaration of parameters to fit (until GUI works)


% For 'fitThis', 1 = fit this parameter; '0' = do not fit this parameter.
fitThis = [1 0 0 ...     %# recombination coefficients
    0 ...      %# SRV
    1 ...      %# D
    0 ...      %# nBack
    0 ...      %# alpha
    0 ...      %# reflection
    0 ...      %# thickness
    0 ...      %# sigma
    0 ...      %# T
    0 ...      %# timeShift
    0 ...      %# PLshift
    0];        %# PL normalization factor


%% 6A-temp. Use finite-difference method to solve for carrier concentration.

% **Solve carrier concentration as a function of x, and t. 2D matrix. Refer to
% outside function (e.g., 'nSolve') which handles many different cases of
% recombFunc, genFunc, and diffFunc. Build this from the ground up.


%% 6B-temp. Calculate PL(t) from carrier concentration.

% **Use finite difference method to calculate integral, or just use a simple
% trapzsum function (I forget the actual name, which is probably different).
% There's only one of these so... could define it here, at the end of this
% function, or in a different function. 'DeltaNtoPL.m'?


%% 6. Run PL fitting routine (see fitPL.m).


% % timeData = linspace(0,10,101);            %# trial time data
% % PLdata = exp(-timeData/0.8);              %# trial PL data


%%% 6a. Run PL fitting routine:
fitPLparams = fitPL(fitThis,timeData,PLdata);


%%% 6b. Calculate fitted TRPL:
ParamsNames = {'SRH coefficient (s^{-1})', 'radiative coefficient',...
    'Auger coefficient', 'SRV (cm/s)', 'D (cm^2/s)', 'nBack (cm^{-3})',...
    'alpha (cm^{-1})', 'reflection', 'thickness (nm)', 'sigma', 'T',...
    'timeShift', 'PLshift', 'PL normalization factor'};

% **I'll need to update 'genType' and 'injectType' sometime.
fittedPL = nSolve(fitPLparams.NewParams,timeData,genType,injectType);


%% 7. Plot, report, and format the results.


%%% 7a. Generate figure and axes (with subplots):
changePlotTRPL;     % script to change plot defaults

figure('Color','w','Position',[200 100 1000 600]);

PLdataColor = [0.7 0.7 0.7];        %# plot display color of original PL data
PLmarker = 2;                       %# plot marker size of original PL data

s1 = subplot(1,3,1:2);
o1 = semilogy(timeData,PLdata,'o','Color',PLdataColor,'MarkerSize',PLmarker);
o1.DisplayName = 'PL data';
hold(s1,'on');

o2 = semilogy(timeData,fittedPL,'--k');
o2.DisplayName = 'fit';
xlabel('time (ns)')
ylabel('normalized PL intensity')
grid(sa,'on')
legend({o1.DisplayName, o2.DisplayName})

s2 = subplot(1,3,3);
Xtext = -0.2;
Ytext = 1;
textColor = copper(14);
set(s2,'YTick','')
set(s2,'Visible','off')

for yy = find(fitThis)
    text(Xtext,Ytext-0.05*yy,sprintf('%s = %1.4g\n', ParamsNames{yy}, ...
        fitPLparams.NewParams(yy)),'Color',textColor(yy,:),...
        'FontSize',14,'FontWeight','bold')
    % Report any lifetimes (if they were fitting parameters):
    % **complete for radiative and Auger components
    if yy == 1
        text(Xtext,0.1,sprintf('%s = %3.1f\n', 'SRH lifetime (ns)',...
            1E9*1/fitPLparams.NewParams(yy)),'Color',textColor(yy,:),...
            'FontSize',14,'FontWeight','bold')
    end
end




% % 
% % text(sb2,Xtext,Ytext,['\color[rgb]{' num2str(ColourSet(ll,1)) ',' num2str(ColourSet(ll,2)) ',' num2str(ColourSet(ll,3)) '}'...
% %         '\tau_1 = ' num2str(BiexpOutParams{ll}(2),'%.3f') '\pm' ...
% %         num2str((BiErrorInFit(2,2)-BiErrorInFit(2,1))/2,'%.3f') ' ns;    '...
% %         '\tau_2 = ' num2str(BiexpOutParams{ll}(4),'%.3f') '\pm' ...
% %         num2str((BiErrorInFit(4,2)-BiErrorInFit(4,1))/2,'%.3f') ' ns'],...
% %         'Fontsize',12,'Units','Normalized');


%% **END FITTING ROUTINE**


%% 7. Report all the parameters, calculate lifetime(s)


%% 8. Report error and perform some fancy sensitivity analysis if you want



end
